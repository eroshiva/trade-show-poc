// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/eroshiva/trade-show-poc/internal/ent/devicestatus"
	"github.com/eroshiva/trade-show-poc/internal/ent/endpoint"
	"github.com/eroshiva/trade-show-poc/internal/ent/networkdevice"
	"github.com/eroshiva/trade-show-poc/internal/ent/predicate"
	"github.com/eroshiva/trade-show-poc/internal/ent/version"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDeviceStatus  = "DeviceStatus"
	TypeEndpoint      = "Endpoint"
	TypeNetworkDevice = "NetworkDevice"
	TypeVersion       = "Version"
)

// DeviceStatusMutation represents an operation that mutates the DeviceStatus nodes in the graph.
type DeviceStatusMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	status                *devicestatus.Status
	last_seen             *string
	clearedFields         map[string]struct{}
	network_device        *string
	clearednetwork_device bool
	done                  bool
	oldValue              func(context.Context) (*DeviceStatus, error)
	predicates            []predicate.DeviceStatus
}

var _ ent.Mutation = (*DeviceStatusMutation)(nil)

// devicestatusOption allows management of the mutation configuration using functional options.
type devicestatusOption func(*DeviceStatusMutation)

// newDeviceStatusMutation creates new mutation for the DeviceStatus entity.
func newDeviceStatusMutation(c config, op Op, opts ...devicestatusOption) *DeviceStatusMutation {
	m := &DeviceStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceStatusID sets the ID field of the mutation.
func withDeviceStatusID(id string) devicestatusOption {
	return func(m *DeviceStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceStatus
		)
		m.oldValue = func(ctx context.Context) (*DeviceStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceStatus sets the old DeviceStatus of the mutation.
func withDeviceStatus(node *DeviceStatus) devicestatusOption {
	return func(m *DeviceStatusMutation) {
		m.oldValue = func(context.Context) (*DeviceStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceStatus entities.
func (m *DeviceStatusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceStatusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceStatusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *DeviceStatusMutation) SetStatus(d devicestatus.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DeviceStatusMutation) Status() (r devicestatus.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DeviceStatus entity.
// If the DeviceStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStatusMutation) OldStatus(ctx context.Context) (v devicestatus.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DeviceStatusMutation) ResetStatus() {
	m.status = nil
}

// SetLastSeen sets the "last_seen" field.
func (m *DeviceStatusMutation) SetLastSeen(s string) {
	m.last_seen = &s
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *DeviceStatusMutation) LastSeen() (r string, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the DeviceStatus entity.
// If the DeviceStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceStatusMutation) OldLastSeen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *DeviceStatusMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[devicestatus.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *DeviceStatusMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[devicestatus.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *DeviceStatusMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, devicestatus.FieldLastSeen)
}

// SetNetworkDeviceID sets the "network_device" edge to the NetworkDevice entity by id.
func (m *DeviceStatusMutation) SetNetworkDeviceID(id string) {
	m.network_device = &id
}

// ClearNetworkDevice clears the "network_device" edge to the NetworkDevice entity.
func (m *DeviceStatusMutation) ClearNetworkDevice() {
	m.clearednetwork_device = true
}

// NetworkDeviceCleared reports if the "network_device" edge to the NetworkDevice entity was cleared.
func (m *DeviceStatusMutation) NetworkDeviceCleared() bool {
	return m.clearednetwork_device
}

// NetworkDeviceID returns the "network_device" edge ID in the mutation.
func (m *DeviceStatusMutation) NetworkDeviceID() (id string, exists bool) {
	if m.network_device != nil {
		return *m.network_device, true
	}
	return
}

// NetworkDeviceIDs returns the "network_device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkDeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceStatusMutation) NetworkDeviceIDs() (ids []string) {
	if id := m.network_device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkDevice resets all changes to the "network_device" edge.
func (m *DeviceStatusMutation) ResetNetworkDevice() {
	m.network_device = nil
	m.clearednetwork_device = false
}

// Where appends a list predicates to the DeviceStatusMutation builder.
func (m *DeviceStatusMutation) Where(ps ...predicate.DeviceStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceStatus).
func (m *DeviceStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceStatusMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status != nil {
		fields = append(fields, devicestatus.FieldStatus)
	}
	if m.last_seen != nil {
		fields = append(fields, devicestatus.FieldLastSeen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicestatus.FieldStatus:
		return m.Status()
	case devicestatus.FieldLastSeen:
		return m.LastSeen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicestatus.FieldStatus:
		return m.OldStatus(ctx)
	case devicestatus.FieldLastSeen:
		return m.OldLastSeen(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicestatus.FieldStatus:
		v, ok := value.(devicestatus.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case devicestatus.FieldLastSeen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicestatus.FieldLastSeen) {
		fields = append(fields, devicestatus.FieldLastSeen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceStatusMutation) ClearField(name string) error {
	switch name {
	case devicestatus.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	}
	return fmt.Errorf("unknown DeviceStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceStatusMutation) ResetField(name string) error {
	switch name {
	case devicestatus.FieldStatus:
		m.ResetStatus()
		return nil
	case devicestatus.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	}
	return fmt.Errorf("unknown DeviceStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.network_device != nil {
		edges = append(edges, devicestatus.EdgeNetworkDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicestatus.EdgeNetworkDevice:
		if id := m.network_device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednetwork_device {
		edges = append(edges, devicestatus.EdgeNetworkDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case devicestatus.EdgeNetworkDevice:
		return m.clearednetwork_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceStatusMutation) ClearEdge(name string) error {
	switch name {
	case devicestatus.EdgeNetworkDevice:
		m.ClearNetworkDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceStatusMutation) ResetEdge(name string) error {
	switch name {
	case devicestatus.EdgeNetworkDevice:
		m.ResetNetworkDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceStatus edge %s", name)
}

// EndpointMutation represents an operation that mutates the Endpoint nodes in the graph.
type EndpointMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	host                  *string
	port                  *string
	protocol              *endpoint.Protocol
	clearedFields         map[string]struct{}
	network_device        *string
	clearednetwork_device bool
	done                  bool
	oldValue              func(context.Context) (*Endpoint, error)
	predicates            []predicate.Endpoint
}

var _ ent.Mutation = (*EndpointMutation)(nil)

// endpointOption allows management of the mutation configuration using functional options.
type endpointOption func(*EndpointMutation)

// newEndpointMutation creates new mutation for the Endpoint entity.
func newEndpointMutation(c config, op Op, opts ...endpointOption) *EndpointMutation {
	m := &EndpointMutation{
		config:        c,
		op:            op,
		typ:           TypeEndpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEndpointID sets the ID field of the mutation.
func withEndpointID(id string) endpointOption {
	return func(m *EndpointMutation) {
		var (
			err   error
			once  sync.Once
			value *Endpoint
		)
		m.oldValue = func(ctx context.Context) (*Endpoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Endpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEndpoint sets the old Endpoint of the mutation.
func withEndpoint(node *Endpoint) endpointOption {
	return func(m *EndpointMutation) {
		m.oldValue = func(context.Context) (*Endpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EndpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EndpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Endpoint entities.
func (m *EndpointMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EndpointMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EndpointMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Endpoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHost sets the "host" field.
func (m *EndpointMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *EndpointMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *EndpointMutation) ResetHost() {
	m.host = nil
}

// SetPort sets the "port" field.
func (m *EndpointMutation) SetPort(s string) {
	m.port = &s
}

// Port returns the value of the "port" field in the mutation.
func (m *EndpointMutation) Port() (r string, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// ResetPort resets all changes to the "port" field.
func (m *EndpointMutation) ResetPort() {
	m.port = nil
}

// SetProtocol sets the "protocol" field.
func (m *EndpointMutation) SetProtocol(e endpoint.Protocol) {
	m.protocol = &e
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *EndpointMutation) Protocol() (r endpoint.Protocol, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the Endpoint entity.
// If the Endpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndpointMutation) OldProtocol(ctx context.Context) (v endpoint.Protocol, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *EndpointMutation) ResetProtocol() {
	m.protocol = nil
}

// SetNetworkDeviceID sets the "network_device" edge to the NetworkDevice entity by id.
func (m *EndpointMutation) SetNetworkDeviceID(id string) {
	m.network_device = &id
}

// ClearNetworkDevice clears the "network_device" edge to the NetworkDevice entity.
func (m *EndpointMutation) ClearNetworkDevice() {
	m.clearednetwork_device = true
}

// NetworkDeviceCleared reports if the "network_device" edge to the NetworkDevice entity was cleared.
func (m *EndpointMutation) NetworkDeviceCleared() bool {
	return m.clearednetwork_device
}

// NetworkDeviceID returns the "network_device" edge ID in the mutation.
func (m *EndpointMutation) NetworkDeviceID() (id string, exists bool) {
	if m.network_device != nil {
		return *m.network_device, true
	}
	return
}

// NetworkDeviceIDs returns the "network_device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkDeviceID instead. It exists only for internal usage by the builders.
func (m *EndpointMutation) NetworkDeviceIDs() (ids []string) {
	if id := m.network_device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkDevice resets all changes to the "network_device" edge.
func (m *EndpointMutation) ResetNetworkDevice() {
	m.network_device = nil
	m.clearednetwork_device = false
}

// Where appends a list predicates to the EndpointMutation builder.
func (m *EndpointMutation) Where(ps ...predicate.Endpoint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EndpointMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EndpointMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Endpoint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EndpointMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EndpointMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Endpoint).
func (m *EndpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EndpointMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.host != nil {
		fields = append(fields, endpoint.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, endpoint.FieldPort)
	}
	if m.protocol != nil {
		fields = append(fields, endpoint.FieldProtocol)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EndpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case endpoint.FieldHost:
		return m.Host()
	case endpoint.FieldPort:
		return m.Port()
	case endpoint.FieldProtocol:
		return m.Protocol()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EndpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case endpoint.FieldHost:
		return m.OldHost(ctx)
	case endpoint.FieldPort:
		return m.OldPort(ctx)
	case endpoint.FieldProtocol:
		return m.OldProtocol(ctx)
	}
	return nil, fmt.Errorf("unknown Endpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case endpoint.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case endpoint.FieldPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case endpoint.FieldProtocol:
		v, ok := value.(endpoint.Protocol)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EndpointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EndpointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Endpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EndpointMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EndpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EndpointMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Endpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EndpointMutation) ResetField(name string) error {
	switch name {
	case endpoint.FieldHost:
		m.ResetHost()
		return nil
	case endpoint.FieldPort:
		m.ResetPort()
		return nil
	case endpoint.FieldProtocol:
		m.ResetProtocol()
		return nil
	}
	return fmt.Errorf("unknown Endpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EndpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.network_device != nil {
		edges = append(edges, endpoint.EdgeNetworkDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EndpointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case endpoint.EdgeNetworkDevice:
		if id := m.network_device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EndpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EndpointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EndpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednetwork_device {
		edges = append(edges, endpoint.EdgeNetworkDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EndpointMutation) EdgeCleared(name string) bool {
	switch name {
	case endpoint.EdgeNetworkDevice:
		return m.clearednetwork_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EndpointMutation) ClearEdge(name string) error {
	switch name {
	case endpoint.EdgeNetworkDevice:
		m.ClearNetworkDevice()
		return nil
	}
	return fmt.Errorf("unknown Endpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EndpointMutation) ResetEdge(name string) error {
	switch name {
	case endpoint.EdgeNetworkDevice:
		m.ResetNetworkDevice()
		return nil
	}
	return fmt.Errorf("unknown Endpoint edge %s", name)
}

// NetworkDeviceMutation represents an operation that mutates the NetworkDevice nodes in the graph.
type NetworkDeviceMutation struct {
	config
	op                Op
	typ               string
	id                *string
	vendor            *networkdevice.Vendor
	model             *string
	hw_version        *string
	clearedFields     map[string]struct{}
	endpoints         map[string]struct{}
	removedendpoints  map[string]struct{}
	clearedendpoints  bool
	sw_version        *string
	clearedsw_version bool
	fw_version        *string
	clearedfw_version bool
	done              bool
	oldValue          func(context.Context) (*NetworkDevice, error)
	predicates        []predicate.NetworkDevice
}

var _ ent.Mutation = (*NetworkDeviceMutation)(nil)

// networkdeviceOption allows management of the mutation configuration using functional options.
type networkdeviceOption func(*NetworkDeviceMutation)

// newNetworkDeviceMutation creates new mutation for the NetworkDevice entity.
func newNetworkDeviceMutation(c config, op Op, opts ...networkdeviceOption) *NetworkDeviceMutation {
	m := &NetworkDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkDeviceID sets the ID field of the mutation.
func withNetworkDeviceID(id string) networkdeviceOption {
	return func(m *NetworkDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkDevice
		)
		m.oldValue = func(ctx context.Context) (*NetworkDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkDevice sets the old NetworkDevice of the mutation.
func withNetworkDevice(node *NetworkDevice) networkdeviceOption {
	return func(m *NetworkDeviceMutation) {
		m.oldValue = func(context.Context) (*NetworkDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NetworkDevice entities.
func (m *NetworkDeviceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkDeviceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkDeviceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVendor sets the "vendor" field.
func (m *NetworkDeviceMutation) SetVendor(n networkdevice.Vendor) {
	m.vendor = &n
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *NetworkDeviceMutation) Vendor() (r networkdevice.Vendor, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldVendor(ctx context.Context) (v networkdevice.Vendor, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *NetworkDeviceMutation) ResetVendor() {
	m.vendor = nil
}

// SetModel sets the "model" field.
func (m *NetworkDeviceMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *NetworkDeviceMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *NetworkDeviceMutation) ResetModel() {
	m.model = nil
}

// SetHwVersion sets the "hw_version" field.
func (m *NetworkDeviceMutation) SetHwVersion(s string) {
	m.hw_version = &s
}

// HwVersion returns the value of the "hw_version" field in the mutation.
func (m *NetworkDeviceMutation) HwVersion() (r string, exists bool) {
	v := m.hw_version
	if v == nil {
		return
	}
	return *v, true
}

// OldHwVersion returns the old "hw_version" field's value of the NetworkDevice entity.
// If the NetworkDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkDeviceMutation) OldHwVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHwVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHwVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHwVersion: %w", err)
	}
	return oldValue.HwVersion, nil
}

// ClearHwVersion clears the value of the "hw_version" field.
func (m *NetworkDeviceMutation) ClearHwVersion() {
	m.hw_version = nil
	m.clearedFields[networkdevice.FieldHwVersion] = struct{}{}
}

// HwVersionCleared returns if the "hw_version" field was cleared in this mutation.
func (m *NetworkDeviceMutation) HwVersionCleared() bool {
	_, ok := m.clearedFields[networkdevice.FieldHwVersion]
	return ok
}

// ResetHwVersion resets all changes to the "hw_version" field.
func (m *NetworkDeviceMutation) ResetHwVersion() {
	m.hw_version = nil
	delete(m.clearedFields, networkdevice.FieldHwVersion)
}

// AddEndpointIDs adds the "endpoints" edge to the Endpoint entity by ids.
func (m *NetworkDeviceMutation) AddEndpointIDs(ids ...string) {
	if m.endpoints == nil {
		m.endpoints = make(map[string]struct{})
	}
	for i := range ids {
		m.endpoints[ids[i]] = struct{}{}
	}
}

// ClearEndpoints clears the "endpoints" edge to the Endpoint entity.
func (m *NetworkDeviceMutation) ClearEndpoints() {
	m.clearedendpoints = true
}

// EndpointsCleared reports if the "endpoints" edge to the Endpoint entity was cleared.
func (m *NetworkDeviceMutation) EndpointsCleared() bool {
	return m.clearedendpoints
}

// RemoveEndpointIDs removes the "endpoints" edge to the Endpoint entity by IDs.
func (m *NetworkDeviceMutation) RemoveEndpointIDs(ids ...string) {
	if m.removedendpoints == nil {
		m.removedendpoints = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.endpoints, ids[i])
		m.removedendpoints[ids[i]] = struct{}{}
	}
}

// RemovedEndpoints returns the removed IDs of the "endpoints" edge to the Endpoint entity.
func (m *NetworkDeviceMutation) RemovedEndpointsIDs() (ids []string) {
	for id := range m.removedendpoints {
		ids = append(ids, id)
	}
	return
}

// EndpointsIDs returns the "endpoints" edge IDs in the mutation.
func (m *NetworkDeviceMutation) EndpointsIDs() (ids []string) {
	for id := range m.endpoints {
		ids = append(ids, id)
	}
	return
}

// ResetEndpoints resets all changes to the "endpoints" edge.
func (m *NetworkDeviceMutation) ResetEndpoints() {
	m.endpoints = nil
	m.clearedendpoints = false
	m.removedendpoints = nil
}

// SetSwVersionID sets the "sw_version" edge to the Version entity by id.
func (m *NetworkDeviceMutation) SetSwVersionID(id string) {
	m.sw_version = &id
}

// ClearSwVersion clears the "sw_version" edge to the Version entity.
func (m *NetworkDeviceMutation) ClearSwVersion() {
	m.clearedsw_version = true
}

// SwVersionCleared reports if the "sw_version" edge to the Version entity was cleared.
func (m *NetworkDeviceMutation) SwVersionCleared() bool {
	return m.clearedsw_version
}

// SwVersionID returns the "sw_version" edge ID in the mutation.
func (m *NetworkDeviceMutation) SwVersionID() (id string, exists bool) {
	if m.sw_version != nil {
		return *m.sw_version, true
	}
	return
}

// SwVersionIDs returns the "sw_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SwVersionID instead. It exists only for internal usage by the builders.
func (m *NetworkDeviceMutation) SwVersionIDs() (ids []string) {
	if id := m.sw_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSwVersion resets all changes to the "sw_version" edge.
func (m *NetworkDeviceMutation) ResetSwVersion() {
	m.sw_version = nil
	m.clearedsw_version = false
}

// SetFwVersionID sets the "fw_version" edge to the Version entity by id.
func (m *NetworkDeviceMutation) SetFwVersionID(id string) {
	m.fw_version = &id
}

// ClearFwVersion clears the "fw_version" edge to the Version entity.
func (m *NetworkDeviceMutation) ClearFwVersion() {
	m.clearedfw_version = true
}

// FwVersionCleared reports if the "fw_version" edge to the Version entity was cleared.
func (m *NetworkDeviceMutation) FwVersionCleared() bool {
	return m.clearedfw_version
}

// FwVersionID returns the "fw_version" edge ID in the mutation.
func (m *NetworkDeviceMutation) FwVersionID() (id string, exists bool) {
	if m.fw_version != nil {
		return *m.fw_version, true
	}
	return
}

// FwVersionIDs returns the "fw_version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FwVersionID instead. It exists only for internal usage by the builders.
func (m *NetworkDeviceMutation) FwVersionIDs() (ids []string) {
	if id := m.fw_version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFwVersion resets all changes to the "fw_version" edge.
func (m *NetworkDeviceMutation) ResetFwVersion() {
	m.fw_version = nil
	m.clearedfw_version = false
}

// Where appends a list predicates to the NetworkDeviceMutation builder.
func (m *NetworkDeviceMutation) Where(ps ...predicate.NetworkDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkDevice).
func (m *NetworkDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkDeviceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.vendor != nil {
		fields = append(fields, networkdevice.FieldVendor)
	}
	if m.model != nil {
		fields = append(fields, networkdevice.FieldModel)
	}
	if m.hw_version != nil {
		fields = append(fields, networkdevice.FieldHwVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkdevice.FieldVendor:
		return m.Vendor()
	case networkdevice.FieldModel:
		return m.Model()
	case networkdevice.FieldHwVersion:
		return m.HwVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkdevice.FieldVendor:
		return m.OldVendor(ctx)
	case networkdevice.FieldModel:
		return m.OldModel(ctx)
	case networkdevice.FieldHwVersion:
		return m.OldHwVersion(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkdevice.FieldVendor:
		v, ok := value.(networkdevice.Vendor)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case networkdevice.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case networkdevice.FieldHwVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHwVersion(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkDeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkDeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkdevice.FieldHwVersion) {
		fields = append(fields, networkdevice.FieldHwVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkDeviceMutation) ClearField(name string) error {
	switch name {
	case networkdevice.FieldHwVersion:
		m.ClearHwVersion()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkDeviceMutation) ResetField(name string) error {
	switch name {
	case networkdevice.FieldVendor:
		m.ResetVendor()
		return nil
	case networkdevice.FieldModel:
		m.ResetModel()
		return nil
	case networkdevice.FieldHwVersion:
		m.ResetHwVersion()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.endpoints != nil {
		edges = append(edges, networkdevice.EdgeEndpoints)
	}
	if m.sw_version != nil {
		edges = append(edges, networkdevice.EdgeSwVersion)
	}
	if m.fw_version != nil {
		edges = append(edges, networkdevice.EdgeFwVersion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkdevice.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.endpoints))
		for id := range m.endpoints {
			ids = append(ids, id)
		}
		return ids
	case networkdevice.EdgeSwVersion:
		if id := m.sw_version; id != nil {
			return []ent.Value{*id}
		}
	case networkdevice.EdgeFwVersion:
		if id := m.fw_version; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedendpoints != nil {
		edges = append(edges, networkdevice.EdgeEndpoints)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkDeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case networkdevice.EdgeEndpoints:
		ids := make([]ent.Value, 0, len(m.removedendpoints))
		for id := range m.removedendpoints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedendpoints {
		edges = append(edges, networkdevice.EdgeEndpoints)
	}
	if m.clearedsw_version {
		edges = append(edges, networkdevice.EdgeSwVersion)
	}
	if m.clearedfw_version {
		edges = append(edges, networkdevice.EdgeFwVersion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case networkdevice.EdgeEndpoints:
		return m.clearedendpoints
	case networkdevice.EdgeSwVersion:
		return m.clearedsw_version
	case networkdevice.EdgeFwVersion:
		return m.clearedfw_version
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkDeviceMutation) ClearEdge(name string) error {
	switch name {
	case networkdevice.EdgeSwVersion:
		m.ClearSwVersion()
		return nil
	case networkdevice.EdgeFwVersion:
		m.ClearFwVersion()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkDeviceMutation) ResetEdge(name string) error {
	switch name {
	case networkdevice.EdgeEndpoints:
		m.ResetEndpoints()
		return nil
	case networkdevice.EdgeSwVersion:
		m.ResetSwVersion()
		return nil
	case networkdevice.EdgeFwVersion:
		m.ResetFwVersion()
		return nil
	}
	return fmt.Errorf("unknown NetworkDevice edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	version       *string
	checksum      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Version, error)
	predicates    []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id string) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Version entities.
func (m *VersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *VersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *VersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *VersionMutation) ResetVersion() {
	m.version = nil
}

// SetChecksum sets the "checksum" field.
func (m *VersionMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *VersionMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *VersionMutation) ResetChecksum() {
	m.checksum = nil
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Version, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.version != nil {
		fields = append(fields, version.FieldVersion)
	}
	if m.checksum != nil {
		fields = append(fields, version.FieldChecksum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldVersion:
		return m.Version()
	case version.FieldChecksum:
		return m.Checksum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldVersion:
		return m.OldVersion(ctx)
	case version.FieldChecksum:
		return m.OldChecksum(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case version.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldVersion:
		m.ResetVersion()
		return nil
	case version.FieldChecksum:
		m.ResetChecksum()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Version edge %s", name)
}
